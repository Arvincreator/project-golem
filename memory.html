<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golem Neural Cortex v8.6</title>
    <style>
        body { font-family: 'Segoe UI', monospace; background: #0d1117; color: #c9d1d9; padding: 20px; }
        .status { padding: 12px; border: 1px solid #30363d; margin-bottom: 10px; border-radius: 6px; background: #161b22; }
        .log { color: #8b949e; font-size: 0.9em; margin-top: 20px; font-family: monospace; border-top: 1px solid #30363d; padding-top: 10px;}
        h1 { color: #58a6ff; font-size: 1.5rem; margin-bottom: 0.5rem; }
        .badge { display: inline-block; padding: 2px 6px; border-radius: 4px; font-size: 0.8em; margin-left: 10px; }
        .badge-browser { background: #1f6feb; color: white; }
        .badge-chronos { background: #d29922; color: white; }
    </style>
</head>
<body>
    <h1>ğŸ§  Golem Neural Cortex <span class="badge badge-browser">v8.6</span> <span class="badge badge-chronos">Chronos</span></h1>
    <div style="color: #8b949e; margin-bottom: 20px;">Browser-based Vector Memory & Timeline Engine (Neuro-Link Ready)</div>

    <div id="model-status" class="status">âš¡ Initializing Transformers.js...</div>
    <div id="db-status" class="status">ğŸ’¾ Connecting to IndexedDB...</div>
    <div id="logs" class="log"></div>

    <script type="module">
        // ä½¿ç”¨ CDN è¼‰å…¥ Transformers.js (ç‰ˆæœ¬å›ºå®šä»¥ç¢ºä¿ç©©å®šæ€§)
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.16.0';

        // è¨­å®šï¼šä¸ä½¿ç”¨æœ¬åœ°å¿«å–æ¨¡å‹æª”æ¡ˆ (ç›´æ¥å¾ CDN æ‹‰å–)
        env.allowLocalModels = false;
        env.useBrowserCache = true;

        let extractor = null;
        let db = null;
        const DB_NAME = 'GolemMemoryDB';
        // âœ¨ [Upgrade] ç‰ˆæœ¬è™Ÿå‡ç´šç‚º 2ï¼Œä»¥è§¸ç™¼çµæ§‹æ›´æ–°
        const DB_VERSION = 2; 
        const STORE_NAME = 'memories';
        const SCHEDULE_STORE = 'schedule'; // âœ¨ æ–°å¢æ’ç¨‹å€‰åº«
        const MODEL_NAME = 'Xenova/all-MiniLM-L6-v2'; // è¼•é‡ç´š Embedding æ¨¡å‹

        // UI Helper
        const log = (msg) => {
            console.log(`[Cortex v8.6] ${msg}`);
            const logDiv = document.getElementById('logs');
            logDiv.innerHTML = `<div><span style="color:#58a6ff">${new Date().toLocaleTimeString()}</span> - ${msg}</div>` + logDiv.innerHTML;
        };

        // 1. åˆå§‹åŒ– AI æ¨¡å‹
        async function initModel() {
            try {
                log(`Loading Model: ${MODEL_NAME}...`);
                // feature-extraction å°ˆé–€ç”¨æ–¼ç”¢ç”Ÿå‘é‡
                extractor = await pipeline('feature-extraction', MODEL_NAME);
                document.getElementById('model-status').innerText = "âœ… Model Active (all-MiniLM-L6-v2)";
                document.getElementById('model-status').style.borderColor = "#238636";
                document.getElementById('model-status').style.color = "#3fb950";
                log("Neural Engine Ready.");
            } catch (e) {
                document.getElementById('model-status').innerText = "âŒ Model Failed: " + e.message;
                document.getElementById('model-status').style.borderColor = "#da3633";
                log("Model Error: " + e.message);
            }
        }

        // 2. åˆå§‹åŒ– IndexedDB (å«å‡ç´šé‚è¼¯)
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    
                    // ç¢ºä¿è¨˜æ†¶å€‰åº«å­˜åœ¨
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    }

                    // âœ¨ [Chronos] æ–°å¢æ’ç¨‹å€‰åº« (å¦‚æœä¸å­˜åœ¨)
                    if (!db.objectStoreNames.contains(SCHEDULE_STORE)) {
                        log("âš™ï¸ Upgrading DB: Creating Schedule Store...");
                        const store = db.createObjectStore(SCHEDULE_STORE, { keyPath: 'id', autoIncrement: true });
                        // å»ºç«‹æ™‚é–“ç´¢å¼•ï¼Œæ–¹ä¾¿æŸ¥è©¢ "æ‰€æœ‰æ—©æ–¼ç¾åœ¨çš„ä»»å‹™"
                        store.createIndex('time', 'time', { unique: false });
                    }
                };

                request.onsuccess = (e) => {
                    db = e.target.result;
                    document.getElementById('db-status').innerText = "âœ… Memory & Timeline Bank Connected";
                    document.getElementById('db-status').style.borderColor = "#238636";
                    document.getElementById('db-status').style.color = "#3fb950";
                    log("Storage Ready (v" + DB_VERSION + ").");
                    resolve();
                };

                request.onerror = (e) => {
                    document.getElementById('db-status').innerText = "âŒ DB Error";
                    reject(e);
                };
            });
        }

        // æ•¸å­¸å·¥å…·ï¼šé¤˜å¼¦ç›¸ä¼¼åº¦
        function cosineSimilarity(vecA, vecB) {
            let dotProduct = 0;
            let normA = 0;
            let normB = 0;
            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                normA += vecA[i] * vecA[i];
                normB += vecB[i] * vecB[i];
            }
            return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
        }

        // ==========================================
        // ğŸš€ é–‹æ”¾çµ¦ Node.js (Puppeteer) å‘¼å«çš„ API
        // ==========================================

        /**
         * å¯«å…¥è¨˜æ†¶
         */
        window.addMemory = async (text, metadata = {}) => {
            if (!extractor || !db) return { success: false, error: "System not ready" };

            try {
                // 1. è½‰å‘é‡
                const output = await extractor(text, { pooling: 'mean', normalize: true });
                const embedding = Array.from(output.data);

                // 2. å­˜å…¥ DB
                const tx = db.transaction(STORE_NAME, 'readwrite');
                const store = tx.objectStore(STORE_NAME);

                const memoryItem = {
                    text: text,
                    embedding: embedding,
                    metadata: metadata,
                    timestamp: Date.now()
                };

                store.add(memoryItem);
                log(`Memorized: "${text.substring(0, 30)}..."`);
                return { success: true };
            } catch (e) {
                return { success: false, error: e.message };
            }
        };

        /**
         * è®€å–/æœå°‹è¨˜æ†¶
         */
        window.queryMemory = async (text, topK = 3) => {
            if (!extractor || !db) return [];

            try {
                // 1. Query è½‰å‘é‡
                const output = await extractor(text, { pooling: 'mean', normalize: true });
                const queryVec = Array.from(output.data);

                // 2. å…¨é‡æƒæ (ç€è¦½å™¨ç«¯ < 10è¬ç­†è³‡æ–™æ¯«ç§’ç´šå®Œæˆ)
                return new Promise((resolve) => {
                    const tx = db.transaction(STORE_NAME, 'readonly');
                    const store = tx.objectStore(STORE_NAME);
                    const request = store.getAll();

                    request.onsuccess = () => {
                        const allMemories = request.result;

                        // 3. è¨ˆç®—ç›¸ä¼¼åº¦
                        const scored = allMemories.map(mem => ({
                            text: mem.text,
                            metadata: mem.metadata,
                            score: cosineSimilarity(queryVec, mem.embedding)
                        }));

                        // 4. æ’åºèˆ‡éæ¿¾ (Threshold: 0.25)
                        scored.sort((a, b) => b.score - a.score);

                        const results = scored
                            .filter(m => m.score > 0.25)
                            .slice(0, topK);

                        if (results.length > 0) {
                            log(`Recall hit: "${results[0].text.substring(0, 20)}..." (${(results[0].score*100).toFixed(0)}%)`);
                        } else {
                            log(`Recall miss for: "${text.substring(0,15)}..."`);
                        }

                        resolve(results);
                    };
                });
            } catch (e) {
                log("Query Error: " + e.message);
                return [];
            }
        };

        // ==========================================
        // â° [Chronos] æ–°å¢ï¼šæ’ç¨‹ç®¡ç† API
        // ==========================================

        /**
         * æ–°å¢æ’ç¨‹ä»»å‹™
         * @param {string} task - ä»»å‹™å…§å®¹
         * @param {string} timeISO - ISO æ ¼å¼çš„æ™‚é–“å­—ä¸²
         */
        window.addSchedule = async (task, timeISO) => {
            if (!db) return { success: false };
            return new Promise((resolve) => {
                const tx = db.transaction(SCHEDULE_STORE, 'readwrite');
                const store = tx.objectStore(SCHEDULE_STORE);
                store.add({
                    task: task,
                    time: timeISO,
                    status: 'pending',
                    createdAt: Date.now()
                });
                tx.oncomplete = () => {
                    log(`ğŸ“… Scheduled: "${task}" at ${timeISO}`);
                    resolve({ success: true });
                };
                tx.onerror = () => resolve({ success: false, error: tx.error });
            });
        };

        /**
         * æª¢æŸ¥ä¸¦å–å‡ºã€Œåˆ°æœŸã€çš„ä»»å‹™
         * (æ­¤å‡½æ•¸æœƒå–å‡ºæ‰€æœ‰ã€Œç¾åœ¨æ™‚é–“ä¹‹å‰ã€çš„ä»»å‹™ï¼Œä¸¦å°‡å…¶å¾ DB åˆªé™¤ï¼Œé¿å…é‡è¤‡åŸ·è¡Œ)
         */
        window.checkSchedule = async () => {
            if (!db) return [];
            const nowISO = new Date().toISOString();

            return new Promise((resolve) => {
                const tx = db.transaction(SCHEDULE_STORE, 'readwrite');
                const store = tx.objectStore(SCHEDULE_STORE);
                const index = store.index('time');
                
                // æœå°‹æ‰€æœ‰æ™‚é–“ <= ç¾åœ¨ çš„ä»»å‹™
                const range = IDBKeyRange.upperBound(nowISO);
                const request = index.openCursor(range);
                
                const dueTasks = [];

                request.onsuccess = (e) => {
                    const cursor = e.target.result;
                    if (cursor) {
                        const record = cursor.value;
                        if (record.status === 'pending') {
                            dueTasks.push(record);
                            // å–å‡ºå¾Œç›´æ¥åˆªé™¤
                            cursor.delete(); 
                        }
                        cursor.continue();
                    } else {
                        // éæ­·çµæŸ
                        if (dueTasks.length > 0) log(`â° Triggered ${dueTasks.length} tasks`);
                        resolve(dueTasks);
                    }
                };
                request.onerror = () => resolve([]);
            });
        };

        // å•Ÿå‹•ç¨‹åº
        (async () => {
            await initDB();
            await initModel();
        })();
    </script>
</body>
</html>
